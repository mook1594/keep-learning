# JPA

### 왜 JPA를 사용하는가?
- SQL 중심적인 개발에서 객체 중심으로 개발의 문제점

### SQL 중심적인 개발의 문제점
#### 지루한 코드의 무한반복
- CRUD 반복
- 자바 객체 <-> SQL, 과정 반복
#### 객체지향과 관계형 데이터베이스간 패러다임 불일치
##### 객체 지향
- 추상화, 캡슐화, 정보은닉, 상속, 다형성 등 복잡성을 제어가능하게 함
- 필드, 메서드를 잘 묶어 캡슐화 사용을 원칙
##### 관계형 데이터베이스
- 데이터를 잘 정규화해서 보관하는 것이 목표
##### 패러다임 불일치
- 캡슐화 하려는 Object를 관계를 맺어 정규화해서 넣으려고하니 문제가 발생
##### 두가지의 차이점
- 상속: 객체-상속개념 존재, RDB-상속관계가 없음
- 연관 관계: 객체-단방향 관게 존재, RDB-양방향관계.단방향은 존재하지않음.
##### 데이터타입
##### 데이터 식별 방법

### 그래서 다시 JPA는 위에 문제를 없애주나?
#### 객체중심적인 개발
#### 생산성
#### 유지보수

### 영속성 관리
- JPA에서 가장 중요한 2가지
    * 설계: 관계형 DB 매핑
    * 내부 동작: 영속성 컨텍스트

#### EntityManagerFactory 와 Entity Manager
##### EntityManagerFactory 
- requst가 일어나 thread가 생성될 때마다 EntityManager를 생성한다.
- application loading 시점에 DB당 딱 하나만 생성되어야 한다.
- WAS 종료 시점에 닫는다. 내부적 connection pooling에 대한 resource가 release됨
##### EntityManager
- 내부적으로 DB connection pool을 사용해서 접근한다.
- 실제 Transaction 단위를 수행할 때마다 생성
- thread간 공유는 안됨 (사용하고 버림)
##### Entity Transaction
- Data를 변경하는 모든 작업은 반드시 Transaction안에서 수행되어야함 (조회는 상관없음)
##### Persistence Context
- 뜻: Entity를 영구적으로 저장하는 환경
- JPA의 가장 중요한 용어, 논리적인 개념 
- DB에 저장하는 것이 아니라 영속성 컨텍스트를 통해서 Entity를 영속화 하는 개념
- Entity를 영속성 컨텍스트에 저장

#### Entity 생명주기
##### 비영속(new/transient)
- 영속성 컨텐츠와 전혀 관계가 없는 상태
##### 영속(managed)
- 영속성 컨텍스트에 저장된 상태
- Entity가 영속성 컨텍스트에 의해 관리되는 상태
- 영속상태가 된다고 바로 쿼리가 날라가지 않음
- 트랜잭션의 commit 시점에 영속성 컨텍스트에 있는 정보들이 DB에 쿼리로 날라감. 
##### 준영속(detached)
- 영속성 컨텍스트에 저장되었다가 분리된 상태
- 영속성에서 지운상태
##### 삭제(removed)
- 실제 DB삭제를 요청한 상태

#### 영속성 컨텍스트의 이점
- 버퍼링, 캐싱 등의 이점
##### 1차 캐시
- 영속성 컨텍스트 내부에 1차 캐시 존재
- DB조회 전 1차 캐시를 먼저 조회
- BUT! 영속성 EntityManager는 Transaction 단위로 만들고 사용자 요청이 종료될때 같이 종료된다.
- 1차캐시도 같이 날라가기때문에 한 Transaction내에서만 효과를 봄
##### 2차 캐시
- 어플리케이션 전체 공유하는 캐시
- 여러명 사용 가능

#### 동일성 보장
- 영속 Entity의 동일성을 보장한다
- 1차 캐시에 의해 같은 Reference로 인식

#### 엔티티 등록시 트랜젝션을 지원하는 쓰기 지연
- 1차 캐시에 저장하고 쓰기지연 SQL저장소에 쿼리를 쌓는다.
- commit 시에 쿼리를 DB로 날린다.

